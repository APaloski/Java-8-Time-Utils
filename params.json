{"name":"Timestreams","tagline":"A small set of utilities for Java 8 that help with working with legacy time code and allow streaming of Java 8 temporal objects","body":"# Timestreams\r\nTimestreams is a small library that adds in additional features to the java.time packages, helping to migrate older code using the older java time APIs as well as allowing use of the java.util.stream APIs with the new time types.\r\n\r\nTime Streams\r\n----------------\r\nTime Streams allow you to create a [Stream](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html) using the java.time data types.\r\n\r\nThe main entry point in temporal streaming is the TemporalStreams class, which provides static factory methods for creating some common streams, such as streaming over every day in a given year, or streaming over all hours in a given day.\r\n\r\nFor instance, if I wanted to look for the first Friday the 13th in the year 2016.\r\n\r\n```java\r\n  Optional<LocalDate> fridayTheThirteenth = TemporalStreams.everyDayInYear(Year.of(2016))\r\n                 .filter(localDate -> localDate.getDayOfMonth() == 13)\r\n                 .filter(localDate -> localDate.getDayOfWeek() == DayOfWeek.FRIDAY)\r\n                 .findFirst();\r\n```\r\n\r\nIf the provided factory methods don't fit your need a Builder is also provided that can be used to create a custom Stream, given the period between times, the starting point and the ending poit.\r\n\r\nFor instance, if I wanted to create a list of every Monday from now until the first of 2017\r\n\r\n```java\r\n  new TemporalStreamBuilder<LocalDate>().every(Period.ofWeeks(1))\r\n                                        .from(LocalDate.of(2016, Month.JANUARY, 1)) //January 1st 2016 is a Friday\r\n                                        .until(LocalDate.of(2016, Month.JANUARY, 1))\r\n                                        .stream()\r\n                                        .collect(Collectors.toList());\r\n```\r\n\r\nClocks\r\n------\r\nA number of custom [Clock](https://docs.oracle.com/javase/8/docs/api/java/time/Clock.html) implementations are provided which should help migration from older code systems that utilize the [Calendar](https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html) or [Date](https://docs.oracle.com/javase/8/docs/api/java/util/Date.html) classes.\r\n\r\nIf we want to get a LocalDate from an external data source, like a server, that returns Calendar instances, we would normally need to do the following\r\n\r\n```java\r\npublic void newerMethod() {\r\n  Calendar externalCalendar = ExternalSource.getCalendar();\r\n  LocalDate calendarTime = LocalDateTime.ofInstant(externalCalendar.toInstant(), externalCalendar.getTimeZone().toZoneId()).toLocalDate();\r\n}\r\n```\r\n\r\nRemembering all of the proper functions for doing this can be a pain, and who needs another static helper method in their code base?\r\n\r\nInstead, using a CalendarClock we can say\r\n\r\n```java\r\n//This can be set at some global singleton level\r\nstatic final Clock exteralClock = CalendarClock.ofSupplier(ExternalSource::getCalendar, ZoneId.systemDefault());\r\n\r\npublic void newerMethod() {\r\n  LocalDate date = LocalDate.now(externalClock);\r\n}\r\n```\r\n\r\nBut what if your code base ranges from brand new to ancient? You need to use Date, Calendar and LocalDate all stemming from the same time provider? \r\n\r\nA LegacyClock allows you to obtain millis UTC, Instants (and from them LocalDate, LocalDateTime, etc.), Date and Calendar objects all from one class via composition. \r\n\r\n```java\r\n//Legacy clock uses the underlying data sources data and provides standard conversions to Calendar, etc.\r\nLegacyClock legacyClock = LegacyClock.of(CalendarClock.ofSupplier(ExternalSource::getCurrentTime, ZoneId.systemDefault()));\r\n\r\npublic void javaOneMethod() {\r\n    Date currentDate = legacyClock.date();\r\n    //Use the Date object...\r\n}\r\n\r\npublic void javaOneDotOneMethod() {\r\n    Calendar currentDateTime = legacyClock.zonedCalendar();\r\n    //Use the Calendar object\r\n}\r\n\r\npublic void javaEightMethod() {\r\n  LocalDateTime ldt = LocalDateTime.now(legacyClock);\r\n  //Use the local date time...\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}